{"version":3,"file":"xjx.min.js","sources":["../../src/core/types/error-types.ts","../../src/core/types/dom-types.ts","../../src/core/adapters/dom-adapter.ts","../../src/core/utils/json-utils.ts","../../src/core/transformers/TransformUtil.ts","../../src/core/converters/xml-to-json-converter.ts","../../src/core/utils/xml-utils.ts","../../src/core/converters/json-to-xml-converter.ts","../../src/core/config/config.ts","../../src/XJX.ts","../../src/core/transformers/ValueTransformer.ts"],"sourcesContent":["/**\n * Error classes for the XJX library\n */\n\n/**\n * Base error class\n */\nexport class XJXError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'XMLToJSONError';\n  }\n}\n\n/**\n * Error for XML parsing issues\n */\nexport class XmlToJsonError extends XJXError {\n  constructor(message: string) {\n    super(`XML parse error: ${message}`);\n    this.name = 'XmlToJsonError';\n  }\n}\n\n/**\n * Error for XML serialization issues\n */\nexport class JsonToXmlError extends XJXError {\n  constructor(message: string) {\n    super(`XML serialization error: ${message}`);\n    this.name = 'JsonToXmlError';\n  }\n}\n\n/**\n * Error for environment incompatibility\n */\nexport class EnvironmentError extends XJXError {\n  constructor(message: string) {\n    super(`Environment error: ${message}`);\n    this.name = 'EnvironmentError';\n  }\n}\n\n/**\n * Error for invalid configuration\n */\nexport class ConfigurationError extends XJXError {\n  constructor(message: string) {\n    super(`Configuration error: ${message}`);\n    this.name = 'ConfigurationError';\n  }\n}","/**\n * DOM node types as an enum for better type safety\n */\nexport enum NodeType {\n    ELEMENT_NODE = 1,\n    ATTRIBUTE_NODE = 2,\n    TEXT_NODE = 3, \n    CDATA_SECTION_NODE = 4,\n    PROCESSING_INSTRUCTION_NODE = 7,\n    COMMENT_NODE = 8,\n    DOCUMENT_NODE = 9\n  }","/**\n * DOM Environment provider with unified interface for browser and Node.js\n */\nimport { XJXError } from '../types/error-types';\nimport { NodeType } from '../types/dom-types';\n\n\ninterface DOMWindow {\n  DOMParser: any;\n  XMLSerializer: any;\n  // Node: {\n  //   ELEMENT_NODE: number;\n  //   TEXT_NODE: number;\n  //   CDATA_SECTION_NODE: number;\n  //   COMMENT_NODE: number;\n  //   PROCESSING_INSTRUCTION_NODE: number;\n  //   DOCUMENT_NODE: number; \n  // };\n  document: Document;\n  close?: () => void; \n}\n\ninterface JSDOMInstance {\n  window: DOMWindow;\n}\n\nexport const DOMAdapter = (() => {\n  // Environment-specific DOM implementation\n  let domParser: any;\n  let xmlSerializer: any;\n  // let nodeTypes: NodeTypes;\n  let docImplementation: any;\n  let jsdomInstance: JSDOMInstance | null = null;\n\n  try {\n    if (typeof window === \"undefined\") {\n      // Node.js environment - try JSDOM first\n      try {\n        const { JSDOM } = require(\"jsdom\");\n        jsdomInstance = new JSDOM(\"<!DOCTYPE html><html><body></body></html>\", {\n          contentType: \"text/xml\",\n        }) as JSDOMInstance;\n\n        domParser = jsdomInstance.window.DOMParser;\n        xmlSerializer = jsdomInstance.window.XMLSerializer;\n        // nodeTypes = {\n        //   ELEMENT_NODE: jsdomInstance.window.Node.ELEMENT_NODE,\n        //   TEXT_NODE: jsdomInstance.window.Node.TEXT_NODE,\n        //   CDATA_SECTION_NODE: jsdomInstance.window.Node.CDATA_SECTION_NODE,\n        //   COMMENT_NODE: jsdomInstance.window.Node.COMMENT_NODE,\n        //   PROCESSING_INSTRUCTION_NODE: jsdomInstance.window.Node.PROCESSING_INSTRUCTION_NODE,\n        //   DOCUMENT_NODE: jsdomInstance.window.Node.DOCUMENT_NODE, // Add this line\n        // };\n        docImplementation = jsdomInstance.window.document.implementation;\n      } catch (jsdomError) {\n        // Fall back to xmldom if JSDOM isn't available\n        try {\n          const { DOMParser, XMLSerializer, DOMImplementation } = require('@xmldom/xmldom');\n          domParser = DOMParser;\n          xmlSerializer = XMLSerializer;\n          // Standard DOM node types\n          // nodeTypes = {\n          //   ELEMENT_NODE: 1,\n          //   TEXT_NODE: 3,\n          //   CDATA_SECTION_NODE: 4,\n          //   COMMENT_NODE: 8,\n          //   PROCESSING_INSTRUCTION_NODE: 7,\n          //   DOCUMENT_NODE: 9, \n          // };\n          const implementation = new DOMImplementation();\n          docImplementation = implementation;\n        } catch (xmldomError) {\n          throw new XJXError(`Node.js environment detected but neither 'jsdom' nor '@xmldom/xmldom' are available.`);\n        }\n      }\n    } else {\n      // Browser environment\n      if (!window.DOMParser) {\n        throw new XJXError(\"DOMParser is not available in this environment\");\n      }\n\n      if (!window.XMLSerializer) {\n        throw new XJXError(\"XMLSerializer is not available in this environment\");\n      }\n\n      domParser = window.DOMParser;\n      xmlSerializer = window.XMLSerializer;\n      // nodeTypes = {\n      //   ELEMENT_NODE: Node.ELEMENT_NODE,\n      //   TEXT_NODE: Node.TEXT_NODE,\n      //   CDATA_SECTION_NODE: Node.CDATA_SECTION_NODE,\n      //   COMMENT_NODE: Node.COMMENT_NODE,\n      //   PROCESSING_INSTRUCTION_NODE: Node.PROCESSING_INSTRUCTION_NODE,\n      //   DOCUMENT_NODE: Node.DOCUMENT_NODE, \n      // };\n      docImplementation = document.implementation;\n    }\n  } catch (error) {\n    throw new XJXError(`DOM environment initialization failed: ${error instanceof Error ? error.message : String(error)}`);\n  }\n\n  return {\n    createParser: () => {\n      try {\n        return new domParser();\n      } catch (error) {\n        throw new XJXError(`Failed to create DOM parser: ${error instanceof Error ? error.message : String(error)}`);\n      }\n    },\n    \n    createSerializer: () => {\n      try {\n        return new xmlSerializer();\n      } catch (error) {\n        throw new XJXError(`Failed to create XML serializer: ${error instanceof Error ? error.message : String(error)}`);\n      }\n    },\n    \n    NodeType,\n    \n    parseFromString: (xmlString: string, contentType: string = 'text/xml') => {\n      try {\n        const parser = new domParser();\n        return parser.parseFromString(xmlString, contentType);\n      } catch (error) {\n        throw new XJXError(`Failed to parse XML: ${error instanceof Error ? error.message : String(error)}`);\n      }\n    },\n    \n    serializeToString: (node: Node) => {\n      try {\n        const serializer = new xmlSerializer();\n        return serializer.serializeToString(node);\n      } catch (error) {\n        throw new XJXError(`Failed to serialize XML: ${error instanceof Error ? error.message : String(error)}`);\n      }\n    },\n    \n    createDocument: () => {\n      try {\n        // For browsers, create a document with a root element to avoid issues\n        if (typeof window !== \"undefined\") {\n          const parser = new domParser();\n          return parser.parseFromString('<temp></temp>', 'text/xml');\n        } else {\n          return docImplementation.createDocument(null, null, null);\n        }\n      } catch (error) {\n        throw new XJXError(`Failed to create document: ${error instanceof Error ? error.message : String(error)}`);\n      }\n    },\n    \n    createElement: (tagName: string) => {\n      try {\n        if (typeof window !== \"undefined\") {\n          return document.createElement(tagName);\n        } else {\n          const doc = docImplementation.createDocument(null, null, null);\n          return doc.createElement(tagName);\n        }\n      } catch (error) {\n        throw new XJXError(`Failed to create element: ${error instanceof Error ? error.message : String(error)}`);\n      }\n    },\n    \n    createElementNS: (namespaceURI: string, qualifiedName: string) => {\n      try {\n        if (typeof window !== \"undefined\") {\n          return document.createElementNS(namespaceURI, qualifiedName);\n        } else {\n          const doc = docImplementation.createDocument(null, null, null);\n          return doc.createElementNS(namespaceURI, qualifiedName);\n        }\n      } catch (error) {\n        throw new XJXError(`Failed to create element with namespace: ${error instanceof Error ? error.message : String(error)}`);\n      }\n    },\n    \n    createTextNode: (data: string) => {\n      try {\n        if (typeof window !== \"undefined\") {\n          return document.createTextNode(data);\n        } else {\n          const doc = docImplementation.createDocument(null, null, null);\n          return doc.createTextNode(data);\n        }\n      } catch (error) {\n        throw new XJXError(`Failed to create text node: ${error instanceof Error ? error.message : String(error)}`);\n      }\n    },\n    \n    createCDATASection: (data: string) => {\n      try {\n        // For browser compatibility, use document.implementation to create CDATA\n        if (typeof window !== \"undefined\") {\n          const doc = document.implementation.createDocument(null, null, null);\n          return doc.createCDATASection(data);\n        } else {\n          const doc = docImplementation.createDocument(null, null, null);\n          return doc.createCDATASection(data);\n        }\n      } catch (error) {\n        throw new XJXError(`Failed to create CDATA section: ${error instanceof Error ? error.message : String(error)}`);\n      }\n    },\n    \n    createComment: (data: string) => {\n      try {\n        if (typeof window !== \"undefined\") {\n          return document.createComment(data);\n        } else {\n          const doc = docImplementation.createDocument(null, null, null);\n          return doc.createComment(data);\n        }\n      } catch (error) {\n        throw new XJXError(`Failed to create comment: ${error instanceof Error ? error.message : String(error)}`);\n      }\n    },\n    \n    createProcessingInstruction: (target: string, data: string) => {\n      try {\n        if (typeof window !== \"undefined\") {\n          const doc = document.implementation.createDocument(null, null, null);\n          return doc.createProcessingInstruction(target, data);\n        } else {\n          const doc = docImplementation.createDocument(null, null, null);\n          return doc.createProcessingInstruction(target, data);\n        }\n      } catch (error) {\n        throw new XJXError(`Failed to create processing instruction: ${error instanceof Error ? error.message : String(error)}`);\n      }\n    },\n    \n    // New helper methods\n    \n    /**\n     * Creates a proper namespace qualified attribute\n     */\n    setNamespacedAttribute: (element: Element, namespaceURI: string | null, qualifiedName: string, value: string): void => {\n      try {\n        if (namespaceURI) {\n          element.setAttributeNS(namespaceURI, qualifiedName, value);\n        } else {\n          element.setAttribute(qualifiedName, value);\n        }\n      } catch (error) {\n        throw new XJXError(`Failed to set attribute: ${error instanceof Error ? error.message : String(error)}`);\n      }\n    },\n    \n    /**\n     * Check if an object is a DOM node\n     */\n    isNode: (obj: any): boolean => {\n      try {\n        return obj && typeof obj === 'object' && typeof obj.nodeType === 'number';\n      } catch (error) {\n        return false;\n      }\n    },\n    \n    /**\n     * Get DOM node type as string for debugging\n     */\n    getNodeTypeName: (nodeType: number): string => {\n      switch (nodeType) {\n        case NodeType.ELEMENT_NODE: return 'ELEMENT_NODE';\n        case NodeType.TEXT_NODE: return 'TEXT_NODE';\n        case NodeType.CDATA_SECTION_NODE: return 'CDATA_SECTION_NODE';\n        case NodeType.COMMENT_NODE: return 'COMMENT_NODE';\n        case NodeType.PROCESSING_INSTRUCTION_NODE: return 'PROCESSING_INSTRUCTION_NODE';\n        default: return `UNKNOWN_NODE_TYPE(${nodeType})`;\n      }\n    },\n    \n    /**\n     * Get all node attributes as an object\n     */\n    getNodeAttributes: (node: Element): Record<string, string> => {\n      const result: Record<string, string> = {};\n      for (let i = 0; i < node.attributes.length; i++) {\n        const attr = node.attributes[i];\n        result[attr.name] = attr.value;\n      }\n      return result;\n    },\n    \n    // Cleanup method (mainly for JSDOM)\n    cleanup: () => {\n      if (jsdomInstance && typeof jsdomInstance.window.close === 'function') {\n        jsdomInstance.window.close();\n      }\n    }\n  };\n})();","/**\n * JSONUtil - Utility functions for JSON processing\n */\nimport { Configuration } from \"../types/config-types\";\nimport { JSONValue, JSONObject, JSONArray, XMLJSONNode, XMLJSONElement } from \"../types/json-types\";\n\nexport class JsonUtil {\n  private config: Configuration;\n\n  /**\n   * Constructor for JSONUtil\n   * @param config Configuration options\n   */\n  constructor(config: Configuration) {\n    this.config = config;\n  }\n\n  /**\n   * Safely retrieves a value from a JSON object using a dot-separated path.\n   * Automatically traverses into children arrays and flattens results.\n   *\n   * @param obj The input JSON object\n   * @param path The dot-separated path string (e.g., \"root.item.description.$val\")\n   * @param fallback Value to return if the path does not resolve\n   * @returns Retrieved value or fallback\n   */\n  getPath(\n    obj: JSONObject,\n    path: string,\n    fallback?: JSONValue\n  ): JSONValue {\n    const segments = path.split(\".\");\n    let current: JSONValue = obj;\n\n    for (const segment of segments) {\n      if (Array.isArray(current)) {\n        // Apply the segment to each array element and flatten results\n        const results: JSONValue[] = current\n          .map((item) => this.resolveSegment(item, segment))\n          .flat()\n          .filter((v): v is JSONValue => v !== undefined);\n        \n        if (results.length === 0) {\n          return fallback as JSONValue;\n        }\n        current = results;\n      } else {\n        const resolved = this.resolveSegment(current, segment);\n        if (resolved === undefined) {\n          return fallback as JSONValue;\n        }\n        current = resolved;\n      }\n    }\n\n    // Collapse singleton arrays\n    if (Array.isArray(current) && current.length === 1) {\n      return current[0];\n    }\n\n    return current;\n  }\n\n  /**\n   * Resolves a single path segment in the context of a JSON object.\n   * Falls back to searching children for matching keys.\n   *\n   * @param obj The current object\n   * @param segment The path segment to resolve\n   * @returns Resolved value or undefined\n   */\n  private resolveSegment(obj: JSONValue, segment: string): JSONValue | undefined {\n    if (obj == null || typeof obj !== \"object\") return undefined;\n    \n    // Handle arrays separately\n    if (Array.isArray(obj)) {\n      return undefined; // Already handled in getPath\n    }\n\n    const objAsRecord = obj as JSONObject;\n\n    // Direct property access\n    if (segment in objAsRecord) {\n      return objAsRecord[segment];\n    }\n\n    // Check if this is a special property name that matches the config\n    if (\n      segment === this.config.propNames.value ||\n      segment === this.config.propNames.children ||\n      segment === this.config.propNames.attributes ||\n      segment === this.config.propNames.namespace ||\n      segment === this.config.propNames.prefix ||\n      segment === this.config.propNames.cdata ||\n      segment === this.config.propNames.comments ||\n      segment === this.config.propNames.instruction ||\n      segment === this.config.propNames.target\n    ) {\n      const configKey = Object.entries(this.config.propNames).find(\n        ([_, value]) => value === segment\n      )?.[0];\n\n      if (configKey && objAsRecord[segment] !== undefined) {\n        return objAsRecord[segment];\n      }\n    }\n\n    // Check children for objects that contain the segment\n    const childrenKey = this.config.propNames.children;\n    const children = objAsRecord[childrenKey];\n    if (Array.isArray(children)) {\n      const childrenArray = children as JSONArray;\n      const matches = childrenArray\n        .map((child) => {\n          if (typeof child === 'object' && child !== null && !Array.isArray(child)) {\n            return segment in (child as JSONObject) ? (child as JSONObject)[segment] : undefined;\n          }\n          return undefined;\n        })\n        .filter((v): v is JSONValue => v !== undefined);\n      return matches.length > 0 ? matches : undefined;\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Converts a plain JSON object to the XML-like JSON structure.\n   * Optionally wraps the result in a root element with attributes and namespaces.\n   *\n   * @param obj Standard JSON object\n   * @param root Optional root element configuration (either a string or object with $ keys)\n   * @returns XML-like JSON object\n   */\n  objectToXJX(obj: JSONValue, root?: string | JSONObject): XMLJSONNode {\n    const wrappedObject = this.wrapObject(obj);\n\n    if (typeof root === \"string\") {\n      // Root is a simple string: wrap result with this root tag\n      return { [root]: wrappedObject as XMLJSONElement };\n    }\n\n    if (root && typeof root === \"object\" && !Array.isArray(root)) {\n      // Handle root with config-based keys\n      const elementName = (root as JSONObject).name as string || \"root\"; // Default to \"root\" if no name is provided\n      const prefix = (root as JSONObject)[this.config.propNames.prefix] as string || \"\";\n      const qualifiedName = prefix ? `${prefix}:${elementName}` : elementName;\n\n      const result: XMLJSONNode = {\n        [qualifiedName]: {} as XMLJSONElement,\n      };\n      \n      const rootElement = result[qualifiedName];\n\n      // Add attributes to the root element if defined\n      const attrsKey = this.config.propNames.attributes;\n      if (root[attrsKey] && Array.isArray(root[attrsKey])) {\n        rootElement[attrsKey] = root[attrsKey] as JSONArray;\n      }\n\n      // Merge existing children with the new generated children\n      const childrenKey = this.config.propNames.children;\n      const children = root[childrenKey] ? root[childrenKey] as JSONArray : [];\n      rootElement[childrenKey] = [\n        ...children,\n        { [elementName]: wrappedObject as XMLJSONElement },\n      ] as unknown as XMLJSONNode[];\n\n      // Add namespace and prefix if defined\n      const nsKey = this.config.propNames.namespace;\n      if (root[nsKey]) {\n        rootElement[nsKey] = root[nsKey] as JSONValue;\n      }\n\n      if (prefix && root[nsKey]) {\n        rootElement[`xmlns:${prefix}`] = root[nsKey] as JSONValue;\n      }\n\n      return result;\n    }\n\n    // Default behavior if no root is provided\n    return wrappedObject as unknown as XMLJSONNode;\n  }\n\n  /**\n   * Wraps a standard JSON value in the XML-like JSON structure\n   * @param value Value to wrap\n   * @returns Wrapped value\n   */\n  private wrapObject(value: JSONValue): JSONObject {\n    const valKey = this.config.propNames.value;\n    const childrenKey = this.config.propNames.children;\n\n    if (\n      value === null ||\n      typeof value === \"string\" ||\n      typeof value === \"number\" ||\n      typeof value === \"boolean\"\n    ) {\n      return { [valKey]: value };\n    }\n\n    if (Array.isArray(value)) {\n      // For arrays, wrap each item and return as a children-style array of repeated elements\n      return {\n        [childrenKey]: value.map((item) => {\n          return this.wrapObject(item);\n        }),\n      };\n    }\n\n    if (typeof value === \"object\" && value !== null) {\n      // It's an object: wrap its properties in children\n      const children = Object.entries(value as JSONObject).map(([key, val]) => ({\n        [key]: this.wrapObject(val),\n      }));\n\n      return { [childrenKey]: children };\n    }\n\n    return { }; // Empty object for unsupported types\n  }\n\n  /**\n   * Check if a value is empty\n   * @param value Value to check\n   * @returns true if empty\n   */\n  isEmpty(value: JSONValue): boolean {\n    if (value == null) return true;\n    if (Array.isArray(value)) return value.length === 0;\n    if (typeof value === \"object\") return Object.keys(value as JSONObject).length === 0;\n    return false;\n  }\n\n  /**\n   * Safely stringify JSON for debugging\n   * @param obj Object to stringify\n   * @param indent Optional indentation level\n   * @returns JSON string representation\n   */\n  safeStringify(obj: JSONValue, indent: number = 2): string {\n    try {\n      return JSON.stringify(obj, null, indent);\n    } catch (error) {\n      return \"[Cannot stringify object]\";\n    }\n  }\n\n/**\n * Deep clone an object\n * @param obj Object to clone\n * @returns Cloned object\n */\ndeepClone<T>(obj: T): T {\n  try {\n    return JSON.parse(JSON.stringify(obj));\n  } catch (error) {\n    throw new Error(\n      `Failed to deep clone object: ${\n        error instanceof Error ? error.message : String(error)\n      }`\n    );\n  }\n}\n\n/**\n * Deep merge two objects with proper type handling\n * @param target Target object\n * @param source Source object\n * @returns Merged object (target is modified)\n */\ndeepMerge<T extends Record<string, any>>(target: T, source: Partial<T>): T {\n  if (!source || typeof source !== \"object\" || source === null) {\n    return target;\n  }\n\n  if (!target || typeof target !== \"object\" || target === null) {\n    return source as T;\n  }\n\n  Object.keys(source).forEach((key) => {\n    const sourceValue = source[key as keyof Partial<T>];\n    const targetValue = target[key as keyof T];\n\n    // If both source and target values are objects, recursively merge them\n    if (\n      sourceValue !== null &&\n      targetValue !== null &&\n      typeof sourceValue === \"object\" &&\n      typeof targetValue === \"object\" &&\n      !Array.isArray(sourceValue) &&\n      !Array.isArray(targetValue)\n    ) {\n      // Recursively merge the nested objects\n      (target as Record<string, any>)[key] = this.deepMerge(\n        targetValue as Record<string, any>, \n        sourceValue as Record<string, any>\n      );\n    } else {\n      // Otherwise just replace the value\n      (target as Record<string, any>)[key] = sourceValue;\n    }\n  });\n\n  return target;\n}\n\n  /**\n   * Generates a JSON schema that matches the current configuration\n   * @returns JSON schema object\n   */\n  generateJsonSchema(): JSONObject {\n    try {\n      const propNames = this.config.propNames;\n      const compact = this.config.outputOptions.compact || false;\n      const preserveNamespaces = this.config.preserveNamespaces;\n      const preserveComments = this.config.preserveComments;\n      const preserveCDATA = this.config.preserveCDATA;\n      const preserveProcessingInstr = this.config.preserveProcessingInstr;\n      const preserveTextNodes = this.config.preserveTextNodes;\n      const preserveWhitespace = this.config.preserveWhitespace;\n      const preserveAttributes = this.config.preserveAttributes;\n\n      // Determine which properties are required based on the configuration\n      const requiredProps: string[] = [];\n\n      if (!compact) {\n        // Only add collections as required if they're preserved in the config\n        if (preserveAttributes) requiredProps.push(propNames.attributes);\n\n        if (preserveCDATA) requiredProps.push(propNames.cdata);\n        if (preserveComments) requiredProps.push(propNames.comments);\n        if (preserveProcessingInstr) requiredProps.push(propNames.instruction);\n        requiredProps.push(propNames.children);\n\n        if (preserveTextNodes) {\n          requiredProps.push(propNames.value);\n\n          if (preserveNamespaces) {\n            requiredProps.push(propNames.namespace);\n            // Note: prefix is not required as it may not be present for all elements\n          }\n        }\n      }\n\n      // Create schema for element properties\n      const elementProperties: JSONObject = {};\n\n      // Add namespace property if preserving namespaces\n      if (preserveNamespaces) {\n        elementProperties[propNames.namespace] = {\n          description: \"Namespace URI of the element\",\n          type: \"string\",\n        };\n\n        // Add prefix property if preserving namespaces\n        elementProperties[propNames.prefix] = {\n          description: \"Namespace prefix of the element\",\n          type: \"string\",\n        };\n      }\n\n      // Add value property if preserving text nodes\n      if (preserveTextNodes) {\n        elementProperties[propNames.value] = {\n          description: \"Text content of the element\",\n          type: \"string\",\n        };\n      }\n\n      // Add attributes property\n      if (preserveAttributes) {\n        elementProperties[propNames.attributes] = {\n          description: \"Element attributes\",\n          type: \"array\",\n          items: {\n            type: \"object\",\n            patternProperties: {\n              \"^.*$\": {\n                type: \"object\",\n                properties: {\n                  [propNames.value]: {\n                    description: \"Attribute value\",\n                    type: \"string\",\n                  },\n                },\n                required: [propNames.value],\n              },\n            },\n            additionalProperties: false,\n          },\n        };\n\n        // If preserving namespaces, add namespace properties to attribute schema\n        if (preserveNamespaces) {\n          const attrPatternProps = (elementProperties[propNames.attributes] as JSONObject)\n            .items as JSONObject;\n          const patternProps = (attrPatternProps.patternProperties as JSONObject)[\"^.*$\"] as JSONObject;\n          const attrProps = patternProps.properties as JSONObject;\n\n          attrProps[propNames.namespace] = {\n            description: \"Namespace URI of the attribute\",\n            type: \"string\",\n          };\n\n          attrProps[propNames.prefix] = {\n            description: \"Namespace prefix of the attribute\",\n            type: \"string\",\n          };\n        }\n      }\n\n      // Add CDATA property if preserving CDATA\n      if (preserveCDATA) {\n        elementProperties[propNames.cdata] = {\n          description: \"CDATA section content\",\n          type: \"string\",\n        };\n      }\n\n      // Add comments property if preserving comments\n      if (preserveComments) {\n        elementProperties[propNames.comments] = {\n          description: \"Comment content\",\n          type: \"string\",\n        };\n      }\n\n      // Add processing instructions property if preserving them\n      if (preserveProcessingInstr) {\n        elementProperties[propNames.instruction] = {\n          description: \"Processing instruction\",\n          type: \"object\",\n          properties: {\n            [propNames.target]: {\n              description: \"Processing instruction target\",\n              type: \"string\",\n            },\n            [propNames.value]: {\n              description: \"Processing instruction content\",\n              type: \"string\",\n            },\n          },\n          required: [propNames.target],\n        };\n      }\n\n      // Add children property with recursive schema\n      elementProperties[propNames.children] = {\n        description: \"Child elements\",\n        type: \"array\",\n        items: {\n          type: \"object\",\n          patternProperties: {\n            \"^.*$\": {\n              $ref: \"#/definitions/element\",\n            },\n          },\n          additionalProperties: false,\n        },\n      };\n\n      // Create element definition (will be referenced recursively)\n      const elementDefinition: JSONObject = {\n        type: \"object\",\n        properties: elementProperties,\n        required: requiredProps,\n        additionalProperties: false,\n      };\n\n      // Build the complete schema\n      const schema: JSONObject = {\n        $schema: \"https://json-schema.org/draft/2020-12/schema\",\n        title: \"XJX JSON Schema\",\n        description:\n          \"Schema for JSON representation of XML documents using the XJX library\",\n        type: \"object\",\n        patternProperties: {\n          \"^.*$\": {\n            $ref: \"#/definitions/element\",\n          },\n        },\n        additionalProperties: false,\n        definitions: {\n          element: elementDefinition,\n        },\n      };\n\n      return schema;\n    } catch (error) {\n      throw new Error(\n        `Schema generation failed: ${\n          error instanceof Error ? error.message : String(error)\n        }`\n      );\n    }\n  }\n\n  /**\n   * Generate an example JSON object based on the schema\n   * @param {string} rootName - Name of the root element\n   * @returns {Record<string, any>} - Example JSON object\n   */\n  generateExample(rootName: string = \"root\"): XMLJSONNode {\n    const propNames = this.config.propNames;\n    const preserveNamespaces = this.config.preserveNamespaces;\n    const preserveComments = this.config.preserveComments;\n    const preserveCDATA = this.config.preserveCDATA;\n    const preserveProcessingInstr = this.config.preserveProcessingInstr;\n    const preserveAttributes = this.config.preserveAttributes;\n\n    // Simple example with common features\n    const example: XMLJSONNode = {\n      [rootName]: {\n        [propNames.value]: \"Root content\",\n        [propNames.children]: [\n          {\n            child: {\n              [propNames.value]: \"Child content\",\n            } as XMLJSONElement,\n          },\n        ] as unknown as XMLJSONNode[],\n      } as XMLJSONElement,\n    };\n\n    const rootElement = example[rootName];\n\n    // Add namespace properties if enabled\n    if (preserveNamespaces) {\n      rootElement[propNames.namespace] = \"http://example.org/ns\";\n      rootElement[propNames.prefix] = \"ex\";\n      \n      const childElement = (rootElement[propNames.children] as unknown as XMLJSONNode[])[0].child;\n      childElement[propNames.namespace] = \"http://example.org/ns\";\n      childElement[propNames.prefix] = \"ex\";\n    }\n\n    // Add attributes if enabled\n    if (preserveAttributes) {\n      rootElement[propNames.attributes] = [\n        { id: { [propNames.value]: \"root-1\" } },\n        { lang: { [propNames.value]: \"en\" } },\n      ] as JSONArray;\n\n      // Add XML namespace prefix to lang attribute if namespaces are preserved\n      if (preserveNamespaces) {\n        const attributesArray = rootElement[propNames.attributes] as JSONArray;\n        if (attributesArray && attributesArray.length > 1) {\n          const langAttrObj = attributesArray[1] as JSONObject;\n          if (langAttrObj && 'lang' in langAttrObj) {\n            const langAttr = langAttrObj['lang'] as JSONObject;\n            if (langAttr) {\n              langAttr[propNames.prefix] = \"xml\";\n            }\n          }\n        }\n      }\n\n      const childElement = (rootElement[propNames.children] as unknown as XMLJSONNode[])[0].child;\n      childElement[propNames.attributes] = [\n        { id: { [propNames.value]: \"child-1\" } },\n      ] as JSONArray;\n    }\n\n    // Add CDATA if enabled\n    if (preserveCDATA) {\n      const childElement = (rootElement[propNames.children] as unknown as XMLJSONNode[])[0].child;\n      childElement[propNames.children] = [\n        { [propNames.cdata]: \"<data>Raw content</data>\" },\n      ] as unknown as XMLJSONNode[];\n    }\n\n    // Add comments if enabled\n    if (preserveComments) {\n      const childElement = (rootElement[propNames.children] as unknown as XMLJSONNode[])[0].child;\n      \n      if (!childElement[propNames.children]) {\n        childElement[propNames.children] = [] as unknown as XMLJSONNode[];\n      }\n\n      const childrenArray = childElement[propNames.children] as unknown as JSONArray;\n      childrenArray.push({\n        [propNames.comments]: \"Comment about the child\",\n      });\n    }\n\n    // Add processing instruction if enabled\n    if (preserveProcessingInstr) {\n      if (!rootElement[propNames.children]) {\n        rootElement[propNames.children] = [] as unknown as XMLJSONNode[];\n      }\n\n      const childrenArray = rootElement[propNames.children] as unknown as JSONArray;\n      childrenArray.unshift({\n        [propNames.instruction]: {\n          [propNames.target]: \"xml-stylesheet\",\n          [propNames.value]: 'type=\"text/css\" href=\"style.css\"',\n        },\n      });\n    }\n\n    return example;\n  }\n}","/**\n * Utilities for applying value transformations\n */\nimport { Configuration } from '../types/config-types';\nimport { TransformContext, TransformDirection } from './ValueTransformer';\nimport { DOMAdapter } from '../adapters/dom-adapter';\n\n/**\n * Utility for applying value transformations\n */\nexport class TransformUtil {\n  private config: Configuration;\n\n  /**\n   * Create a new TransformUtil\n   * @param config Configuration\n   */\n  constructor(config: Configuration) {\n    this.config = config;\n  }\n\n  /**\n   * Apply transforms to a value\n   * @param value Value to transform\n   * @param context Transformation context\n   * @returns Transformed value\n   */\n  applyTransforms(value: any, context: TransformContext): any {\n    // Skip transformation if no transformers are configured\n    if (!this.config.valueTransforms || this.config.valueTransforms.length === 0) {\n      return value;\n    }\n\n    // Apply each transformer in sequence\n    let transformedValue = value;\n    for (const transformer of this.config.valueTransforms) {\n      transformedValue = transformer.process(transformedValue, context);\n    }\n\n    return transformedValue;\n  }\n\n  /**\n   * Create a transform context\n   * @param direction Direction of transformation\n   * @param nodeName Name of the current node\n   * @param nodeType DOM node type\n   * @param options Additional context options\n   * @returns Transform context\n   */\n  createContext(\n    direction: TransformDirection,\n    nodeName: string,\n    nodeType: number,\n    options: {\n      path?: string;\n      namespace?: string;\n      prefix?: string;\n      isAttribute?: boolean;\n      attributeName?: string;\n      parent?: TransformContext;\n    } = {}\n  ): TransformContext {\n    return {\n      direction,\n      nodeName,\n      nodeType,\n      path: options.path || nodeName,\n      namespace: options.namespace,\n      prefix: options.prefix,\n      isAttribute: options.isAttribute || false,\n      attributeName: options.attributeName,\n      parent: options.parent,\n      config: this.config,\n    };\n  }\n\n  /**\n   * Get a user-friendly node type name for debugging\n   * @param nodeType DOM node type\n   * @returns String representation of node type\n   */\n  getNodeTypeName(nodeType: number): string {\n    return DOMAdapter.getNodeTypeName(nodeType);\n  }\n}","/**\n * XmlToJsonConverter class for converting XML to JSON with consistent namespace handling\n */\nimport { Configuration } from \"../types/config-types\";\nimport { XJXError } from \"../types/error-types\";\nimport { DOMAdapter } from \"../adapters/dom-adapter\";\nimport { JsonUtil } from \"../utils/json-utils\";\nimport { TransformUtil } from \"../transformers/TransformUtil\";\nimport { TransformContext } from \"../transformers/ValueTransformer\";\n\n/**\n * XmlToJsonConverter Parser for converting XML to JSON\n */\nexport class XmlToJsonConverter {\n  private config: Configuration;\n  private jsonUtil: JsonUtil;\n  private transformUtil: TransformUtil;\n\n  /**\n   * Constructor for XmlToJsonConverter\n   * @param config Configuration options\n   */\n  constructor(config: Configuration) {\n    this.config = config;\n    this.jsonUtil = new JsonUtil(this.config);\n    this.transformUtil = new TransformUtil(this.config);\n  }\n\n  /**\n   * Convert XML string to JSON\n   * @param xmlString XML content as string\n   * @returns JSON object representing the XML content\n   */\n  public convert(xmlString: string): Record<string, any> {\n    try {\n      const xmlDoc = DOMAdapter.parseFromString(xmlString, \"text/xml\");\n\n      // Check for parsing errors\n      const errors = xmlDoc.getElementsByTagName(\"parsererror\");\n      if (errors.length > 0) {\n        throw new XJXError(`XML parsing error: ${errors[0].textContent}`);\n      }\n\n      return this.nodeToJson(xmlDoc.documentElement);\n    } catch (error) {\n      throw new XJXError(\n        `Failed to convert XML to JSON: ${\n          error instanceof Error ? error.message : String(error)\n        }`\n      );\n    }\n  }\n\n  /**\n   * Convert a DOM node to JSON representation\n   * @param node DOM node to convert\n   * @param parentContext Optional parent context for transformation chain\n   * @param path Current path in the XML tree\n   * @returns JSON representation of the node\n   */\n  private nodeToJson(node: Node, parentContext?: TransformContext, path: string = \"\"): Record<string, any> {\n    const result: Record<string, any> = {};\n\n    // Handle element nodes\n    if (node.nodeType === DOMAdapter.NodeType.ELEMENT_NODE) {\n      const element = node as Element;\n      // Use localName instead of nodeName to strip namespace prefix\n      const nodeName =\n        element.localName ||\n        element.nodeName.split(\":\").pop() ||\n        element.nodeName;\n\n      // Update the current path\n      const currentPath = path ? `${path}.${nodeName}` : nodeName;\n\n      const nodeObj: Record<string, any> = {};\n\n      // Create context for this node\n      const context = this.transformUtil.createContext(\n        'xml-to-json',\n        nodeName,\n        node.nodeType,\n        {\n          path: currentPath,\n          namespace: element.namespaceURI || undefined,\n          prefix: element.prefix || undefined,\n          parent: parentContext\n        }\n      );\n\n      // Process namespaces if enabled\n      if (this.config.preserveNamespaces) {\n        const ns = element.namespaceURI;\n        if (ns) {\n          nodeObj[this.config.propNames.namespace] = ns;\n        }\n\n        const prefix = element.prefix;\n        if (prefix) {\n          nodeObj[this.config.propNames.prefix] = prefix;\n        }\n      }\n\n      // Process attributes if enabled\n      if (this.config.preserveAttributes && element.attributes.length > 0) {\n        const attrs: Array<Record<string, any>> = [];\n\n        for (let i = 0; i < element.attributes.length; i++) {\n          const attr = element.attributes[i];\n          // Strip namespace prefix from attribute name\n          const attrLocalName =\n            attr.localName || attr.name.split(\":\").pop() || attr.name;\n\n          // Create attribute context\n          const attrContext = this.transformUtil.createContext(\n            'xml-to-json',\n            nodeName,\n            node.nodeType,\n            {\n              path: `${currentPath}.${attrLocalName}`,\n              namespace: attr.namespaceURI || undefined,\n              prefix: attr.prefix || undefined,\n              isAttribute: true,\n              attributeName: attrLocalName,\n              parent: context\n            }\n          );\n\n          // Apply transformations to attribute value\n          const transformedValue = this.transformUtil.applyTransforms(\n            attr.value,\n            attrContext\n          );\n\n          // Create attribute object with consistent structure\n          const attrObj: Record<string, any> = {\n            [attrLocalName]: {\n              [this.config.propNames.value]: transformedValue,\n            },\n          };\n\n          // Add namespace info for attribute if present and enabled\n          if (this.config.preserveNamespaces) {\n            // Handle attribute namespace\n            if (attr.namespaceURI) {\n              attrObj[attrLocalName][this.config.propNames.namespace] =\n                attr.namespaceURI;\n            }\n\n            // Handle attribute prefix\n            if (attr.prefix) {\n              attrObj[attrLocalName][this.config.propNames.prefix] =\n                attr.prefix;\n            }\n          }\n\n          attrs.push(attrObj);\n        }\n\n        if (attrs.length > 0) {\n          nodeObj[this.config.propNames.attributes] = attrs;\n        }\n      }\n\n      // Process child nodes\n      if (element.childNodes.length > 0) {\n        const children: Array<Record<string, any>> = [];\n        const childrenKey = this.config.propNames.children;\n        const valueKey = this.config.propNames.value;\n        const cdataKey = this.config.propNames.cdata;\n        const commentsKey = this.config.propNames.comments;\n        const instructionKey = this.config.propNames.instruction;\n        const targetKey = this.config.propNames.target;\n\n        for (let i = 0; i < element.childNodes.length; i++) {\n          const child = element.childNodes[i];\n\n          // Text nodes - only process if preserveTextNodes is true\n          if (child.nodeType === DOMAdapter.NodeType.TEXT_NODE) {\n            if (this.config.preserveTextNodes) {\n              let text = child.nodeValue || \"\";\n\n              // Skip whitespace-only text nodes if whitespace preservation is disabled\n              if (!this.config.preserveWhitespace) {\n                if (text.trim() === \"\") {\n                  continue;\n                }\n                // Trim the text when preserveWhitespace is false\n                text = text.trim();\n              }\n\n              // Create text node context\n              const textContext = this.transformUtil.createContext(\n                'xml-to-json',\n                '#text',\n                child.nodeType,\n                {\n                  path: `${currentPath}.#text`,\n                  parent: context\n                }\n              );\n\n              // Apply transformations to text value\n              const transformedText = this.transformUtil.applyTransforms(\n                text,\n                textContext\n              );\n\n              children.push({ [valueKey]: transformedText });\n            }\n          }\n          // CDATA sections\n          else if (\n            child.nodeType === DOMAdapter.NodeType.CDATA_SECTION_NODE &&\n            this.config.preserveCDATA\n          ) {\n            // Create CDATA context\n            const cdataContext = this.transformUtil.createContext(\n              'xml-to-json',\n              '#cdata',\n              child.nodeType,\n              {\n                path: `${currentPath}.#cdata`,\n                parent: context\n              }\n            );\n\n            // Apply transformations to CDATA value\n            const transformedCData = this.transformUtil.applyTransforms(\n              child.nodeValue || \"\",\n              cdataContext\n            );\n\n            children.push({\n              [cdataKey]: transformedCData,\n            });\n          }\n          // Comments\n          else if (\n            child.nodeType === DOMAdapter.NodeType.COMMENT_NODE &&\n            this.config.preserveComments\n          ) {\n            children.push({\n              [commentsKey]: child.nodeValue || \"\",\n            });\n          }\n          // Processing instructions\n          else if (\n            child.nodeType ===\n              DOMAdapter.NodeType.PROCESSING_INSTRUCTION_NODE &&\n            this.config.preserveProcessingInstr\n          ) {\n            children.push({\n              [instructionKey]: {\n                [targetKey]: child.nodeName,\n                [valueKey]: child.nodeValue || \"\",\n              },\n            });\n          }\n          // Element nodes (recursive)\n          else if (child.nodeType === DOMAdapter.NodeType.ELEMENT_NODE) {\n            children.push(this.nodeToJson(child, context, currentPath));\n          }\n        }\n\n        if (children.length > 0) {\n          nodeObj[childrenKey] = children;\n        }\n      }\n\n      // Apply compact option - remove empty properties if enabled\n      if (this.config.outputOptions.compact) {\n        Object.keys(nodeObj).forEach((key) => {\n          const cleaned = this.cleanNode(nodeObj[key]);\n          if (cleaned === undefined) {\n            delete nodeObj[key];\n          } else {\n            nodeObj[key] = cleaned;\n          }\n        });\n      }\n\n      result[nodeName] = nodeObj;\n    }\n\n    return result;\n  }\n\n  private cleanNode(node: any): any {\n    if (Array.isArray(node)) {\n      // Clean each item in the array and filter out empty ones\n      const cleanedArray = node\n        .map((item) => this.cleanNode(item))\n        .filter((item) => {\n          return !(\n            item === null ||\n            item === undefined ||\n            (typeof item === \"object\" && Object.keys(item).length === 0)\n          );\n        });\n      return cleanedArray.length > 0 ? cleanedArray : undefined;\n    } else if (typeof node === \"object\" && node !== null) {\n      // Clean properties recursively\n      Object.keys(node).forEach((key) => {\n        const cleanedChild = this.cleanNode(node[key]);\n        if (\n          cleanedChild === null ||\n          cleanedChild === undefined ||\n          (Array.isArray(cleanedChild) && cleanedChild.length === 0) ||\n          (typeof cleanedChild === \"object\" &&\n            Object.keys(cleanedChild).length === 0)\n        ) {\n          delete node[key];\n        } else {\n          node[key] = cleanedChild;\n        }\n      });\n\n      // Handle the special case for nodes with only empty children/attributes\n      const childrenKey = this.config.propNames.children;\n      const attrsKey = this.config.propNames.attributes;\n      const keys = Object.keys(node);\n      if (\n        keys.every((key) => key === childrenKey || key === attrsKey) &&\n        (node[childrenKey] === undefined ||\n          this.jsonUtil.isEmpty(node[childrenKey])) &&\n        (node[attrsKey] === undefined || this.jsonUtil.isEmpty(node[attrsKey]))\n      ) {\n        return undefined;\n      }\n\n      return Object.keys(node).length > 0 ? node : undefined;\n    }\n\n    return node;\n  }\n}","/**\n * XMLUtil - Utility functions for XML processing\n */\nimport { XJXError } from \"../types/error-types\";\nimport { DOMAdapter } from \"../adapters/dom-adapter\";\nimport { Configuration } from \"../types/config-types\";\nimport { NodeType } from \"../types/dom-types\";\n\n/**\n * Interface for XML validation result\n */\nexport interface ValidationResult {\n  isValid: boolean;\n  message?: string;\n}\n\nexport class XmlUtil {\n  private config: Configuration;\n\n  /**\n   * Constructor for XMLUtil\n   * @param config Configuration options\n   */\n  constructor(config: Configuration) {\n    this.config = config;\n  }\n\n  /**\n   * Pretty print an XML string\n   * @param xmlString XML string to format\n   * @returns Formatted XML string\n   */\n  prettyPrintXml(xmlString: string): string {\n    const indent = this.config.outputOptions.indent;\n    const INDENT = \" \".repeat(indent);\n\n    try {\n      const doc = DOMAdapter.parseFromString(xmlString, \"text/xml\");\n\n      const serializer = (node: Node, level = 0): string => {\n        const pad = INDENT.repeat(level);\n\n        switch (node.nodeType) {\n          case DOMAdapter.NodeType.ELEMENT_NODE: {\n            const el = node as Element;\n            const tagName = el.tagName;\n            const attrs = Array.from(el.attributes)\n              .map((a) => `${a.name}=\"${a.value}\"`)\n              .join(\" \");\n            const openTag = attrs ? `<${tagName} ${attrs}>` : `<${tagName}>`;\n\n            const children = Array.from(el.childNodes);\n\n            if (children.length === 0) {\n              return `${pad}${openTag.replace(/>$/, \" />\")}\\n`;\n            }\n\n            // Single text node: print inline\n            if (\n              children.length === 0 ||\n              (children.length === 1 &&\n                children[0].nodeType === DOMAdapter.NodeType.TEXT_NODE &&\n                children[0].textContent?.trim() === \"\")\n            ) {\n              // Empty or whitespace-only\n              return `${pad}<${tagName}${\n                attrs ? \" \" + attrs : \"\"\n              }></${tagName}>\\n`;\n            }\n\n            const inner = children\n              .map((child) => serializer(child, level + 1))\n              .join(\"\");\n            return `${pad}${openTag}\\n${inner}${pad}</${tagName}>\\n`;\n          }\n\n          case DOMAdapter.NodeType.TEXT_NODE: {\n            const text = node.textContent?.trim();\n            return text ? `${pad}${text}\\n` : \"\";\n          }\n\n          case DOMAdapter.NodeType.CDATA_SECTION_NODE:\n            return `${pad}<![CDATA[${node.nodeValue}]]>\\n`;\n\n          case DOMAdapter.NodeType.COMMENT_NODE:\n            return `${pad}<!--${node.nodeValue}-->\\n`;\n\n          case DOMAdapter.NodeType.PROCESSING_INSTRUCTION_NODE:\n            const pi = node as ProcessingInstruction;\n            return `${pad}<?${pi.target} ${pi.data}?>\\n`;\n\n          case DOMAdapter.NodeType.DOCUMENT_NODE:\n            return Array.from(node.childNodes)\n              .map((child) => serializer(child, level))\n              .join(\"\");\n\n          default:\n            return \"\";\n        }\n      };\n\n      return serializer(doc).trim();\n    } catch (error) {\n      throw new XJXError(\n        `Failed to pretty print XML: ${\n          error instanceof Error ? error.message : String(error)\n        }`\n      );\n    }\n  }\n\n  /**\n   * Check if XML string is well-formed\n   * @param xmlString XML string to validate\n   * @returns Object with validation result and any error messages\n   */\n  validateXML(xmlString: string): ValidationResult {\n    try {\n      const doc = DOMAdapter.parseFromString(xmlString, \"text/xml\");\n      const errors = doc.getElementsByTagName(\"parsererror\");\n      if (errors.length > 0) {\n        return {\n          isValid: false,\n          message: errors[0].textContent || \"Unknown parsing error\",\n        };\n      }\n      return { isValid: true };\n    } catch (error) {\n      return {\n        isValid: false,\n        message: error instanceof Error ? error.message : String(error),\n      };\n    }\n  }\n\n  /**\n   * Add XML declaration to a string if missing\n   * @param xmlString XML string\n   * @returns XML string with declaration\n   */\n  ensureXMLDeclaration(xmlString: string): string {\n    if (!xmlString.trim().startsWith(\"<?xml\")) {\n      return '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n' + xmlString;\n    }\n    return xmlString;\n  }\n\n  /**\n   * Escapes special characters in text for safe XML usage.\n   * @param text Text to escape.\n   * @returns Escaped XML string.\n   */\n  escapeXML(text: string): string {\n    if (typeof text !== \"string\" || text.length === 0) {\n      return \"\";\n    }\n\n    return text.replace(/[&<>\"']/g, (char) => {\n      switch (char) {\n        case \"&\":\n          return \"&amp;\";\n        case \"<\":\n          return \"&lt;\";\n        case \">\":\n          return \"&gt;\";\n        case '\"':\n          return \"&quot;\";\n        case \"'\":\n          return \"&apos;\";\n        default:\n          return char;\n      }\n    });\n  }\n\n  /**\n   * Unescapes XML entities back to their character equivalents.\n   * @param text Text with XML entities.\n   * @returns Unescaped text.\n   */\n  unescapeXML(text: string): string {\n    if (typeof text !== \"string\" || text.length === 0) {\n      return \"\";\n    }\n\n    return text.replace(/&(amp|lt|gt|quot|apos);/g, (match, entity) => {\n      switch (entity) {\n        case \"amp\":\n          return \"&\";\n        case \"lt\":\n          return \"<\";\n        case \"gt\":\n          return \">\";\n        case \"quot\":\n          return '\"';\n        case \"apos\":\n          return \"'\";\n        default:\n          return match;\n      }\n    });\n  }\n\n  /**\n   * Extract the namespace prefix from a qualified name\n   * @param qualifiedName Qualified name (e.g., \"ns:element\")\n   * @returns Prefix or null if no prefix\n   */\n  extractPrefix(qualifiedName: string): string | null {\n    const colonIndex = qualifiedName.indexOf(\":\");\n    return colonIndex > 0 ? qualifiedName.substring(0, colonIndex) : null;\n  }\n\n  /**\n   * Extract the local name from a qualified name\n   * @param qualifiedName Qualified name (e.g., \"ns:element\")\n   * @returns Local name\n   */\n  extractLocalName(qualifiedName: string): string {\n    const colonIndex = qualifiedName.indexOf(\":\");\n    return colonIndex > 0\n      ? qualifiedName.substring(colonIndex + 1)\n      : qualifiedName;\n  }\n\n  /**\n   * Create a qualified name from prefix and local name\n   * @param prefix Namespace prefix (can be null)\n   * @param localName Local name\n   * @returns Qualified name\n   */\n  createQualifiedName(prefix: string | null, localName: string): string {\n    return prefix ? `${prefix}:${localName}` : localName;\n  }\n}\n","/**\n * JsonToXmlConverter class for converting JSON to XML with consistent namespace handling\n */\nimport { Configuration } from \"../types/config-types\";\nimport { XJXError } from \"../types/error-types\";\nimport { DOMAdapter } from \"../adapters/dom-adapter\";\nimport { XmlUtil } from \"../utils/xml-utils\";\nimport { TransformUtil } from \"../transformers/TransformUtil\";\nimport { TransformContext } from \"../transformers/ValueTransformer\";\n\n/**\n * JsonToXmlConverter for converting JSON to XML\n */\nexport class JsonToXmlConverter {\n  private config: Configuration;\n  private xmlUtil: XmlUtil;\n  private transformUtil: TransformUtil;\n\n  /**\n   * Constructor for JsonToXmlConverter\n   * @param config Configuration options\n   */\n  constructor(config: Configuration) {\n    this.config = config;\n    this.xmlUtil = new XmlUtil(this.config);\n    this.transformUtil = new TransformUtil(this.config);\n  }\n\n  /**\n   * Convert JSON object to XML string\n   * @param jsonObj JSON object to convert\n   * @returns XML string\n   */\n  public convert(jsonObj: Record<string, any>): string {\n    try {\n      const doc = DOMAdapter.createDocument();\n      const rootElement = this.jsonToNode(jsonObj, doc);\n\n      if (rootElement) {\n        // Handle the temporary root element if it exists\n        if (doc.documentElement && doc.documentElement.nodeName === \"temp\") {\n          doc.replaceChild(rootElement, doc.documentElement);\n        } else {\n          doc.appendChild(rootElement);\n        }\n      }\n\n      // Add XML declaration if specified\n      let xmlString = DOMAdapter.serializeToString(doc);\n\n      // remove xhtml decl inserted by dom\n      xmlString = xmlString.replace(' xmlns=\"http://www.w3.org/1999/xhtml\"', '');\n\n      if (this.config.outputOptions.xml.declaration) {\n        xmlString = this.xmlUtil.ensureXMLDeclaration(xmlString);\n      }\n\n      // Apply pretty printing if enabled\n      if (this.config.outputOptions.prettyPrint) {\n        xmlString = this.xmlUtil.prettyPrintXml(xmlString);\n      }\n\n      return xmlString;\n    } catch (error) {\n      throw new XJXError(\n        `Failed to convert JSON to XML: ${\n          error instanceof Error ? error.message : String(error)\n        }`\n      );\n    }\n  }\n\n  /**\n   * Convert JSON object to DOM node\n   * @param jsonObj JSON object to convert\n   * @param doc Document for creating elements\n   * @param parentContext Optional parent context for transformation chain\n   * @param path Current path in the JSON object\n   * @returns DOM Element\n   */\n  private jsonToNode(\n    jsonObj: Record<string, any>,\n    doc: Document,\n    parentContext?: TransformContext,\n    path: string = \"\"\n  ): Element | null {\n    if (!jsonObj || typeof jsonObj !== \"object\") {\n      return null;\n    }\n\n    // Get the node name (first key in the object)\n    const nodeName = Object.keys(jsonObj)[0];\n    if (!nodeName) {\n      return null;\n    }\n\n    const nodeData = jsonObj[nodeName];\n    \n    // Update the current path\n    const currentPath = path ? `${path}.${nodeName}` : nodeName;\n\n    // Create element with namespace if available\n    let element: Element;\n    const namespaceKey = this.config.propNames.namespace;\n    const prefixKey = this.config.propNames.prefix;\n    const ns = nodeData[namespaceKey];\n    const prefix = nodeData[prefixKey];\n\n    // Create context for this node\n    const context = this.transformUtil.createContext(\n      'json-to-xml',\n      nodeName,\n      DOMAdapter.NodeType.ELEMENT_NODE,\n      {\n        path: currentPath,\n        namespace: ns,\n        prefix: prefix,\n        parent: parentContext\n      }\n    );\n\n    if (ns && this.config.preserveNamespaces) {\n      if (prefix) {\n        // Create element with namespace and prefix\n        element = DOMAdapter.createElementNS(ns, `${prefix}:${nodeName}`);\n      } else {\n        // Create element with namespace but no prefix\n        element = DOMAdapter.createElementNS(ns, nodeName);\n      }\n    } else {\n      // Create element without namespace\n      element = DOMAdapter.createElement(nodeName);\n    }\n\n    // Process attributes if enabled\n    const attributesKey = this.config.propNames.attributes;\n    const valueKey = this.config.propNames.value;\n    if (\n      this.config.preserveAttributes &&\n      nodeData[attributesKey] &&\n      Array.isArray(nodeData[attributesKey])\n    ) {\n      nodeData[attributesKey].forEach(\n        (attrObj: Record<string, any>) => {\n          const attrName = Object.keys(attrObj)[0];\n          if (!attrName) return;\n\n          const attrData = attrObj[attrName];\n          \n          // Create attribute context\n          const attrContext = this.transformUtil.createContext(\n            'json-to-xml',\n            nodeName,\n            DOMAdapter.NodeType.ELEMENT_NODE,\n            {\n              path: `${currentPath}.${attrName}`,\n              namespace: attrData[namespaceKey],\n              prefix: attrData[prefixKey],\n              isAttribute: true,\n              attributeName: attrName,\n              parent: context\n            }\n          );\n          \n          // Apply transformations to attribute value\n          const transformedValue = this.transformUtil.applyTransforms(\n            attrData[valueKey] || \"\",\n            attrContext\n          );\n          \n          const attrNs = attrData[namespaceKey];\n          const attrPrefix = attrData[prefixKey];\n\n          // Form qualified name for attribute if it has a prefix\n          let qualifiedName = attrName;\n          if (attrPrefix && this.config.preserveNamespaces) {\n            qualifiedName = `${attrPrefix}:${attrName}`;\n          }\n\n          DOMAdapter.setNamespacedAttribute(\n            element, \n            (attrNs && this.config.preserveNamespaces) ? attrNs : null, \n            qualifiedName, \n            transformedValue\n          );\n        }\n      );\n    }\n\n    // Process simple text value\n    if (nodeData[valueKey] !== undefined) {\n      // Apply transformations to text value\n      const textContext = this.transformUtil.createContext(\n        'json-to-xml',\n        nodeName,\n        DOMAdapter.NodeType.TEXT_NODE,\n        {\n          path: `${currentPath}.#text`,\n          namespace: ns,\n          prefix: prefix,\n          parent: context\n        }\n      );\n      \n      const transformedValue = this.transformUtil.applyTransforms(\n        nodeData[valueKey],\n        textContext\n      );\n      \n      element.textContent = transformedValue;\n    }\n\n    // Process children\n    const childrenKey = this.config.propNames.children;\n    const cdataKey = this.config.propNames.cdata;\n    const commentsKey = this.config.propNames.comments;\n    const instructionKey = this.config.propNames.instruction;\n    const targetKey = this.config.propNames.target;\n\n    if (\n      nodeData[childrenKey] &&\n      Array.isArray(nodeData[childrenKey])\n    ) {\n      nodeData[childrenKey].forEach(\n        (child: Record<string, any>) => {\n          // Text nodes\n          if (\n            child[valueKey] !== undefined &&\n            this.config.preserveTextNodes\n          ) {\n            // Apply transformations to text node\n            const textContext = this.transformUtil.createContext(\n              'json-to-xml',\n              '#text',\n              DOMAdapter.NodeType.TEXT_NODE,\n              {\n                path: `${currentPath}.#text`,\n                parent: context\n              }\n            );\n            \n            const transformedText = this.transformUtil.applyTransforms(\n              child[valueKey],\n              textContext\n            );\n            \n            element.appendChild(\n              DOMAdapter.createTextNode(this.xmlUtil.escapeXML(transformedText))\n            );\n          }\n          // CDATA sections\n          else if (\n            child[cdataKey] !== undefined &&\n            this.config.preserveCDATA\n          ) {\n            // Apply transformations to CDATA\n            const cdataContext = this.transformUtil.createContext(\n              'json-to-xml',\n              '#cdata',\n              DOMAdapter.NodeType.CDATA_SECTION_NODE,\n              {\n                path: `${currentPath}.#cdata`,\n                parent: context\n              }\n            );\n            \n            const transformedCData = this.transformUtil.applyTransforms(\n              child[cdataKey],\n              cdataContext\n            );\n            \n            element.appendChild(\n              DOMAdapter.createCDATASection(\n                transformedCData\n              )\n            );\n          }\n          // Comments\n          else if (\n            child[commentsKey] !== undefined &&\n            this.config.preserveComments\n          ) {\n            element.appendChild(\n              DOMAdapter.createComment(\n                child[commentsKey]\n              )\n            );\n          }\n          // Processing instructions\n          else if (\n            child[instructionKey] !== undefined &&\n            this.config.preserveProcessingInstr\n          ) {\n            const piData = child[instructionKey];\n            const target = piData[targetKey];\n            const data = piData[valueKey] || \"\";\n\n            if (target) {\n              element.appendChild(\n                DOMAdapter.createProcessingInstruction(target, data)\n              );\n            }\n          }\n          // Element nodes (recursive)\n          else {\n            const childElement = this.jsonToNode(child, doc, context, currentPath);\n            if (childElement) {\n              element.appendChild(childElement);\n            }\n          }\n        }\n      );\n    }\n\n    return element;\n  }\n}","/**\n * Default configuration for the XJX library\n */\nimport { Configuration } from '../types/config-types';\n\n/**\n * Default configuration\n */\nexport const DEFAULT_CONFIG: Configuration = {\n  preserveNamespaces: true,\n  preserveComments: true,\n  preserveProcessingInstr: true,\n  preserveCDATA: true,\n  preserveTextNodes: true,\n  preserveWhitespace: false,\n  preserveAttributes: true,\n\n  outputOptions: {\n    prettyPrint: true,\n    indent: 2,\n    compact: true,\n    json: {},\n    xml: {\n      declaration: true,\n    },\n  },\n\n  propNames: {\n    namespace: \"$ns\",\n    prefix: \"$pre\",\n    attributes: \"$attr\",\n    value: \"$val\",\n    cdata: \"$cdata\",\n    comments: \"$cmnt\",\n    instruction: \"$pi\", \n    target: \"$trgt\",  \n    children: \"$children\",\n  },\n};","/**\n * XJX - Facade class for XML-JSON conversion operations\n */\nimport { XmlToJsonConverter } from \"./core/converters/xml-to-json-converter\";\nimport { JsonToXmlConverter } from \"./core/converters/json-to-xml-converter\";\nimport { Configuration } from \"./core/types/config-types\";\nimport { DEFAULT_CONFIG } from \"./core/config/config\";\nimport { DOMAdapter } from \"./core/adapters/dom-adapter\";\nimport { XmlUtil } from \"./core/utils/xml-utils\";\nimport { JsonUtil } from \"./core/utils/json-utils\";\nimport { ValueTransformer } from \"./core/transformers\";\n\nexport class XJX {\n  private config: Configuration;\n  private xmlToJsonConverter: XmlToJsonConverter;\n  private jsonToXmlConverter: JsonToXmlConverter;\n  private jsonUtil: JsonUtil;\n  private xmlUtil: XmlUtil;\n\n  /**\n   * Constructor for XJX utility\n   * @param config Configuration options\n   */\n  constructor(config: Partial<Configuration> = {}) {\n    // First create a jsonUtil instance with default config to use its methods\n    this.jsonUtil = new JsonUtil(DEFAULT_CONFIG);\n  \n    // Create a deep clone of the default config\n    const defaultClone = this.jsonUtil.deepClone(DEFAULT_CONFIG);\n  \n    // Deep merge with the provided config\n    this.config = this.jsonUtil.deepMerge(defaultClone, config);\n  \n    // Re-initialize jsonUtil with the merged config\n    this.jsonUtil = new JsonUtil(this.config);\n  \n    // Initialize other components\n    this.xmlUtil = new XmlUtil(this.config);\n    this.xmlToJsonConverter = new XmlToJsonConverter(this.config);\n    this.jsonToXmlConverter = new JsonToXmlConverter(this.config);\n  }\n\n  /**\n   * Convert XML string to JSON\n   * @param xmlString XML content as string\n   * @returns JSON object representing the XML content\n   */\n  public xmlToJson(xmlString: string): Record<string, any> {\n    return this.xmlToJsonConverter.convert(xmlString);\n  }\n\n  /**\n   * Convert JSON object back to XML string\n   * @param jsonObj JSON object to convert\n   * @returns XML string\n   */\n  public jsonToXml(jsonObj: Record<string, any>): string {\n    return this.jsonToXmlConverter.convert(jsonObj);\n  }\n\n  /**\n   * Pretty print an XML string\n   * @param xmlString XML string to format\n   * @returns Formatted XML string\n   */\n  public prettyPrintXml(xmlString: string): string {\n    return this.xmlUtil.prettyPrintXml(xmlString);\n  }\n\n  /**\n   * Safely retrieves a value from a JSON object using a dot-separated path.\n   * @param obj The input JSON object\n   * @param path The dot-separated path string (e.g., \"root.item.description.$val\")\n   * @param fallback Value to return if the path does not resolve\n   * @returns The value at the specified path or the fallback value\n   */\n  public getPath(\n    obj: Record<string, any>,\n    path: string,\n    fallback: any = undefined\n  ): any {\n    return this.jsonUtil.getPath(obj, path, fallback);\n  }\n\n  /**\n   * Validate XML string\n   * @param xmlString XML string to validate\n   * @returns Validation result\n   */\n  public validateXML(xmlString: string): {\n    isValid: boolean;\n    message?: string;\n  } {\n    return this.xmlUtil.validateXML(xmlString);\n  }\n\n  /**\n   * Generate a JSON schema based on the current configuration\n   * @returns JSON schema object for validating XML-JSON documents\n   */\n  public generateJsonSchema(): Record<string, any> {\n    return this.jsonUtil.generateJsonSchema();\n  }\n\n  /**\n   * Convert a standard JSON object to the XML-like JSON structure\n   * @param obj Standard JSON object\n   * @param root Optional root element configuration (string or object with properties)\n   * @returns XML-like JSON object ready for conversion to XML\n   */\n  public objectToXJX(obj: any, root?: string | Record<string, any>): Record<string, any> {\n    return this.jsonUtil.objectToXJX(obj, root);\n  }\n\n  /**\n   * Generate an example JSON object that matches the current configuration\n   * @param rootName Name of the root element\n   * @returns Example JSON object\n   */\n  public generateJsonExample(rootName: string = \"root\"): Record<string, any> {\n    return this.jsonUtil.generateExample(rootName);\n  }\n\n  /**\n   * Add a value transformer to the configuration\n   * @param transformer Value transformer to add\n   * @returns This XJX instance for chaining\n   */\n  public addTransformer(transformer: ValueTransformer): XJX {\n    if (!this.config.valueTransforms) {\n      this.config.valueTransforms = [];\n    }\n    this.config.valueTransforms.push(transformer);\n    return this;\n  }\n\n  /**\n   * Removes all value transformers from the configuration\n   * @returns This XJX instance for chaining\n   */\n  public clearTransformers(): XJX {\n    this.config.valueTransforms = [];\n    return this;\n  }\n\n  /**\n   * Clean up any resources\n   */\n  public cleanup(): void {\n    DOMAdapter.cleanup();\n  }\n}","/**\n * Value transformation types and base class for the XJX library\n */\nimport { Configuration } from '../types/config-types';\n\n/**\n * Direction of the transformation\n */\nexport type TransformDirection = 'xml-to-json' | 'json-to-xml';\n\n/**\n * Context provided to value transformers\n */\nexport interface TransformContext {\n  // Core transformation info\n  direction: TransformDirection;  // Direction of the current transformation\n  \n  // Node information\n  nodeName: string;              // Name of the current node\n  nodeType: number;              // DOM node type (element, text, etc.)\n  namespace?: string;            // Namespace URI if available\n  prefix?: string;               // Namespace prefix if available\n  \n  // Structure information\n  path: string;                  // Dot-notation path to current node\n  isAttribute: boolean;          // Whether the current value is from an attribute\n  attributeName?: string;        // Name of attribute if isAttribute is true\n  \n  // Parent context (creates a chain)\n  parent?: TransformContext;     // Reference to parent context for traversal\n  \n  // Configuration reference\n  config: Configuration;         // Reference to the current configuration\n}\n\n/**\n * Abstract base class for value transformers\n */\nexport abstract class ValueTransformer {\n  /**\n   * Process a value, transforming it if applicable\n   * @param value Value to potentially transform\n   * @param context Context including direction and other information\n   * @returns Transformed value or original if not applicable\n   */\n  process(value: any, context: TransformContext): any {\n    if (context.direction === 'xml-to-json') {\n      return this.xmlToJson(value, context);\n    } else {\n      return this.jsonToXml(value, context);\n    }\n  }\n\n  /**\n   * Transform a value from XML to JSON representation\n   * @param value Value from XML\n   * @param context Transformation context\n   * @returns Transformed value for JSON\n   */\n  protected xmlToJson(value: any, context: TransformContext): any {\n    // Default implementation returns original value\n    return value;\n  }\n\n  /**\n   * Transform a value from JSON to XML representation\n   * @param value Value from JSON\n   * @param context Transformation context\n   * @returns Transformed value for XML\n   */\n  protected jsonToXml(value: any, context: TransformContext): any {\n    // Default implementation returns original value\n    return value;\n  }\n}"],"names":["XJXError","Error","constructor","message","super","this","name","NodeType","DOMAdapter","domParser","xmlSerializer","docImplementation","jsdomInstance","window","JSDOM","require","contentType","DOMParser","XMLSerializer","document","implementation","jsdomError","DOMImplementation","xmldomError","error","String","createParser","createSerializer","parseFromString","xmlString","serializeToString","node","createDocument","createElement","tagName","createElementNS","namespaceURI","qualifiedName","createTextNode","data","createCDATASection","createComment","createProcessingInstruction","target","setNamespacedAttribute","element","value","setAttributeNS","setAttribute","isNode","obj","nodeType","getNodeTypeName","ELEMENT_NODE","TEXT_NODE","CDATA_SECTION_NODE","COMMENT_NODE","PROCESSING_INSTRUCTION_NODE","getNodeAttributes","result","i","attributes","length","attr","cleanup","close","JsonUtil","config","getPath","path","fallback","segments","split","current","segment","Array","isArray","results","map","item","resolveSegment","flat","filter","v","undefined","resolved","objAsRecord","propNames","children","namespace","prefix","cdata","comments","instruction","configKey","Object","entries","find","_","matches","child","objectToXJX","root","wrappedObject","wrapObject","elementName","rootElement","attrsKey","childrenKey","nsKey","valKey","key","val","isEmpty","keys","safeStringify","indent","JSON","stringify","deepClone","parse","deepMerge","source","forEach","sourceValue","targetValue","generateJsonSchema","compact","outputOptions","preserveNamespaces","preserveComments","preserveCDATA","preserveProcessingInstr","preserveTextNodes","preserveAttributes","preserveWhitespace","requiredProps","push","elementProperties","description","type","items","patternProperties","properties","required","additionalProperties","attrPatternProps","attrProps","$ref","$schema","title","definitions","generateExample","rootName","example","childElement","id","lang","attributesArray","langAttrObj","langAttr","unshift","TransformUtil","applyTransforms","context","valueTransforms","transformedValue","transformer","process","createContext","direction","nodeName","options","isAttribute","attributeName","parent","XmlToJsonConverter","jsonUtil","transformUtil","convert","xmlDoc","errors","getElementsByTagName","textContent","nodeToJson","documentElement","parentContext","localName","pop","currentPath","nodeObj","ns","attrs","attrLocalName","attrContext","attrObj","childNodes","valueKey","cdataKey","commentsKey","instructionKey","targetKey","text","nodeValue","trim","textContext","transformedText","cdataContext","transformedCData","cleaned","cleanNode","cleanedArray","cleanedChild","every","XmlUtil","prettyPrintXml","INDENT","repeat","doc","serializer","level","pad","el","from","a","join","openTag","replace","pi","DOCUMENT_NODE","validateXML","isValid","ensureXMLDeclaration","startsWith","escapeXML","char","unescapeXML","match","entity","extractPrefix","colonIndex","indexOf","substring","extractLocalName","createQualifiedName","JsonToXmlConverter","xmlUtil","jsonObj","jsonToNode","replaceChild","appendChild","xml","declaration","prettyPrint","nodeData","namespaceKey","prefixKey","attributesKey","attrName","attrData","attrNs","attrPrefix","piData","DEFAULT_CONFIG","json","XJX","defaultClone","xmlToJsonConverter","jsonToXmlConverter","xmlToJson","jsonToXml","generateJsonExample","addTransformer","clearTransformers"],"mappings":"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"}