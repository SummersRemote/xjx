// =====================================================================================
// DateFormatExtension.ts
//
// Extension that adds date formatting transformers to XJX.
// =====================================================================================

// --- Imports ---
import { 
    XJX, 
    TransformDirection, 
    BaseValueTransformer, 
    XNode, 
    TransformContext,
    ExtensionRegistry 
  } from '../index';
  
  // =====================================================================================
  // Interface Definitions
  // =====================================================================================
  
  /**
   * Date format patterns
   */
  export interface DateFormats {
    /**
     * ISO 8601 format (e.g., "2023-04-15T14:30:45.123Z")
     */
    ISO: string;
    
    /**
     * Short date format (e.g., "04/15/2023")
     */
    SHORT: string;
    
    /**
     * Medium date format (e.g., "Apr 15, 2023")
     */
    MEDIUM: string;
    
    /**
     * Long date format (e.g., "April 15, 2023")
     */
    LONG: string;
    
    /**
     * Full date format (e.g., "Saturday, April 15, 2023")
     */
    FULL: string;
    
    /**
     * Date time format (e.g., "Apr 15, 2023 2:30:45 PM")
     */
    DATETIME: string;
    
    /**
     * Time only format (e.g., "14:30:45")
     */
    TIME: string;
    
    /**
     * Unix timestamp (milliseconds since epoch)
     */
    TIMESTAMP: string;
  }
  
  /**
   * Options for date format transformer
   */
  export interface DateFormatOptions {
    /**
     * Paths to apply this transformer to
     * Uses path matching syntax (e.g., "root.items.*.date")
     */
    paths?: string | string[];
    
    /**
     * Input format pattern
     * Can be a predefined format key or a custom format string
     */
    inputFormat: keyof DateFormats | string;
    
    /**
     * Output format pattern
     * Can be a predefined format key or a custom format string
     */
    outputFormat: keyof DateFormats | string;
    
    /**
     * Locale for formatting (default: "en-US")
     */
    locale?: string;
    
    /**
     * Timezone offset in minutes (default: local timezone)
     */
    timezoneOffset?: number;
  }
  
  // =====================================================================================
  // Implementation
  // =====================================================================================
  
  /**
   * Predefined date formats
   */
  const DATE_FORMATS: DateFormats = {
    ISO: 'ISO',                // Special case, uses Date.toISOString()
    SHORT: 'MM/dd/yyyy',       // 04/15/2023
    MEDIUM: 'MMM dd, yyyy',    // Apr 15, 2023
    LONG: 'MMMM dd, yyyy',     // April 15, 2023
    FULL: 'EEEE, MMMM dd, yyyy', // Saturday, April 15, 2023
    DATETIME: 'MMM dd, yyyy h:mm:ss a', // Apr 15, 2023 2:30:45 PM
    TIME: 'HH:mm:ss',          // 14:30:45
    TIMESTAMP: 'timestamp'     // Special case, returns numeric timestamp
  };
  
  /**
   * Date format transformer class
   */
  export class DateFormatTransformer extends BaseValueTransformer {
    private options: DateFormatOptions;
    
    /**
     * Create a new date format transformer
     * @param options Transformer options
     */
    constructor(options: DateFormatOptions) {
      super(options.paths);
      this.options = {
        locale: 'en-US',
        ...options
      };
    }
    
    /**
     * Transform a date value
     * @param value Value to transform
     * @param node Node containing the value
     * @param context Transformation context
     * @returns Transformed date string
     */
    protected transformValue(value: any, node: XNode, context: TransformContext): any {
      // Skip non-string and non-number values
      if (typeof value !== 'string' && typeof value !== 'number') {
        return value;
      }
      
      try {
        // Parse the input date
        const date = this.parseDate(value, this.options.inputFormat);
        if (!date) {
          return value;
        }
        
        // Apply timezone offset if specified
        if (this.options.timezoneOffset !== undefined) {
          const currentOffset = date.getTimezoneOffset();
          const targetOffset = this.options.timezoneOffset;
          const offsetDiff = targetOffset - currentOffset;
          date.setMinutes(date.getMinutes() + offsetDiff);
        }
        
        // Format the date
        return this.formatDate(date, this.options.outputFormat, this.options.locale);
      } catch (error) {
        // Return original value if parsing or formatting fails
        return value;
      }
    }
  
    /**
     * Parse a date string using the specified format
     * @param value Date string or timestamp
     * @param format Format to parse with
     * @returns Date object or null if parsing fails
     */
    private parseDate(value: string | number, format: string): Date | null {
      // Handle numeric timestamps
      if (typeof value === 'number') {
        return new Date(value);
      }
      
      // Handle ISO format
      if (format === 'ISO') {
        return new Date(value);
      }
      
      // Handle timestamp format
      if (format === 'timestamp') {
        const timestamp = parseInt(value, 10);
        if (!isNaN(timestamp)) {
          return new Date(timestamp);
        }
        return null;
      }
      
      // Get the format pattern if it's a predefined format
      const formatPattern = (DATE_FORMATS as Record<string, string>)[format] || format;
      
      // For custom formats, we need to implement a parser
      // This is a simplified parser for demonstration purposes
      
      // Convert format pattern to regex pattern
      let pattern = formatPattern
        .replace(/yyyy/g, '(\\d{4})')
        .replace(/MM/g, '(\\d{1,2})')
        .replace(/dd/g, '(\\d{1,2})')
        .replace(/HH/g, '(\\d{1,2})')
        .replace(/mm/g, '(\\d{1,2})')
        .replace(/ss/g, '(\\d{1,2})')
        .replace(/SSS/g, '(\\d{1,3})')
        .replace(/MMMM/g, '([A-Za-z]+)')
        .replace(/MMM/g, '([A-Za-z]+)')
        .replace(/EEEE/g, '([A-Za-z]+)')
        .replace(/a/g, '(AM|PM|am|pm)');
      
      // Escape remaining non-captured characters
      pattern = pattern.replace(/([^\(\)\\])/g, (match) => {
        return /[.*+?^${}()|[\]\\]/.test(match) ? '\\' + match : match;
      });
      
      const regex = new RegExp('^' + pattern + '$');
      const match = value.match(regex);
      
      if (!match) {
        return null;
      }
      
      // Create a new date with default values
      const date = new Date(0);
      date.setUTCHours(0, 0, 0, 0);
      
      // Extract capture groups and update date
      let index = 1;
      
      if (formatPattern.includes('yyyy')) {
        date.setUTCFullYear(parseInt(match[index++], 10));
      }
      
      if (formatPattern.includes('MM')) {
        date.setUTCMonth(parseInt(match[index++], 10) - 1);
      } else if (formatPattern.includes('MMMM') || formatPattern.includes('MMM')) {
        const monthName = match[index++];
        const months = formatPattern.includes('MMMM')
          ? ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']
          : ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
        
        const monthIndex = months.findIndex(
          m => m.toLowerCase() === monthName.toLowerCase()
        );
        
        if (monthIndex >= 0) {
          date.setUTCMonth(monthIndex);
        }
      }
      
      if (formatPattern.includes('dd')) {
        date.setUTCDate(parseInt(match[index++], 10));
      }
      
      if (formatPattern.includes('HH')) {
        date.setUTCHours(parseInt(match[index++], 10));
      }
      
      if (formatPattern.includes('mm')) {
        date.setUTCMinutes(parseInt(match[index++], 10));
      }
      
      if (formatPattern.includes('ss')) {
        date.setUTCSeconds(parseInt(match[index++], 10));
      }
      
      if (formatPattern.includes('SSS')) {
        date.setUTCMilliseconds(parseInt(match[index++], 10));
      }
      
      if (formatPattern.includes('a')) {
        const ampm = match[index++];
        if (ampm.toLowerCase() === 'pm') {
          date.setUTCHours(date.getUTCHours() + 12);
        }
      }
      
      // Skip day of week (EEEE) as it doesn't affect the date value
      
      return date;
    }
  
    /**
     * Format a date using the specified format
     * @param date Date to format
     * @param format Format to use
     * @param locale Locale to use
     * @returns Formatted date string
     */
    private formatDate(date: Date, format: string, locale: string = 'en-US'): string {
      // Handle special formats
      if (format === 'ISO') {
        return date.toISOString();
      }
      
      if (format === 'timestamp') {
        return date.getTime().toString();
      }
      
      // Get the format pattern if it's a predefined format
      const formatPattern = (DATE_FORMATS as Record<string, string>)[format] || format;
      
      // Use Intl.DateTimeFormat for locale-aware formatting
      const intlOptions: Intl.DateTimeFormatOptions = {};
      
      if (formatPattern.includes('yyyy') || formatPattern.includes('MMMM') || 
          formatPattern.includes('MMM') || formatPattern.includes('MM')) {
        intlOptions.year = 'numeric';
        
        if (formatPattern.includes('MMMM')) {
          intlOptions.month = 'long';
        } else if (formatPattern.includes('MMM')) {
          intlOptions.month = 'short';
        } else if (formatPattern.includes('MM')) {
          intlOptions.month = '2-digit';
        }
      }
      
      if (formatPattern.includes('dd')) {
        intlOptions.day = '2-digit';
      }
      
      if (formatPattern.includes('HH') || formatPattern.includes('h')) {
        intlOptions.hour = formatPattern.includes('h') ? 'numeric' : '2-digit';
        intlOptions.hour12 = formatPattern.includes('a');
      }
      
      if (formatPattern.includes('mm')) {
        intlOptions.minute = '2-digit';
      }
      
      if (formatPattern.includes('ss')) {
        intlOptions.second = '2-digit';
      }
      
      if (formatPattern.includes('SSS')) {
        intlOptions.fractionalSecondDigits = 3;
      }
      
      if (formatPattern.includes('EEEE')) {
        intlOptions.weekday = 'long';
      }
      
      // Create formatted date parts
      const formatter = new Intl.DateTimeFormat(locale, intlOptions);
      const formatted = formatter.format(date);
      
      // For patterns that don't match Intl.DateTimeFormat options, we need custom formatting
      // This is a simplified example
      if (formatPattern !== 'FULL' && formatPattern !== 'LONG' && 
          formatPattern !== 'MEDIUM' && formatPattern !== 'SHORT' && 
          formatPattern !== 'DATETIME' && formatPattern !== 'TIME') {
        
        // For more complex custom formats, we would implement a full custom formatter here
        // This would replace tokens with actual date values
        return formatted;
      }
      
      return formatted;
    }
  }
  
  // =====================================================================================
  // Factory Method
  // =====================================================================================
  
  /**
   * Factory method to create a date format transformer
   * This method is added to XJX instances by the extension
   */
  function createDateFormatTransformer(this: XJX, options: DateFormatOptions): DateFormatTransformer {
    return new DateFormatTransformer(options);
  }
  
  // =====================================================================================
  // Extension Registration
  // =====================================================================================
  
  /**
   * Apply the date format extension to XJX
   */
  export function extendXJXWithDateFormat(): void {
    // Register the factory method
    ExtensionRegistry.registerMethod('dateFormat', createDateFormatTransformer);
  }
  
  // =====================================================================================
  // TypeScript Module Augmentation
  // =====================================================================================
  
  // Add the dateFormat method to XJX interface
  declare module '../core/XJX' {
    interface XJX {
      /**
       * Create a date format transformer
       * @param options Date format options
       * @returns Date format transformer instance
       */
      dateFormat(options: DateFormatOptions): DateFormatTransformer;
    }
  }
  
  // =====================================================================================
  // Auto-run extension
  // =====================================================================================
  
  extendXJXWithDateFormat();
  
  // =====================================================================================
  // Example usage
  //
  // import { XJX, TransformDirection } from '../core/XJX';
  // import './extensions/DateFormatExtension';
  //
  // const xjx = new XJX();
  //
  // // Create a transformer to convert ISO dates to human-readable format
  // const dateTransformer = xjx.dateFormat({
  //   paths: ['root.items.*.date', 'root.metadata.created'],
  //   inputFormat: 'ISO',
  //   outputFormat: 'MEDIUM'
  // });
  //
  // // Apply the transformer to JSON→XML direction
  // xjx.transformValue(TransformDirection.JSON_TO_XML, dateTransformer);
  //
  // // Apply a different transformer for XML→JSON direction
  // xjx.transformValue(TransformDirection.XML_TO_JSON, xjx.dateFormat({
  //   paths: ['root.items.*.date', 'root.metadata.created'],
  //   inputFormat: 'MEDIUM',
  //   outputFormat: 'ISO'
  // }));
  // =====================================================================================